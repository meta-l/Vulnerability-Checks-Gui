# OpenSource Vulnerability Checks GUI
# version 1.1.3
# Ian Simons
# 30/07/2019



#region initialise

# initialise session to enable proxy communication
$browser = New-Object System.Net.WebClient
$browser.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials

# Debug help
$DebugPreference = "Continue"


# patch tuesday paths

$ptCurrentUser = $env:USERNAME
$ptHomepath = "C:\Users\$ptCurrentUser\documents"
$ptFilename = "$ptHomepath\MS_Monthly_CVE.csv"
$ptFilename_raw = "$ptHomepath\MS_Monthly_Raw.csv"
$ptAPIKey = 'insert_API_key_here'

# RSS paths
$rssHomepath = "C:\Users\$ptCurrentUser\documents"
$rssWorkingdirectory = "$rssHomepath\RssChecks"
#if(!(Test-Path $rssWorkingDirectory)) {write-host "{!} Creating 'RSSChecks'" -ForegroundColor Red;New-Item -ItemType Directory -Force $rssWorkingDirectory}
$rssFilename = "$rssWorkingDirectory\rssfinal.csv"


# import modules. Must be already saved in "C:\Users\$env:USERNAME\Documents\Windows PowerShell\Modules"
import-module MSrcSecurityUpdates

# send API key to enable functionality
Set-MSRCApiKey -ApiKey $ptAPIKey

# unhide cursor to show activity
# not valid in GUI
# [Console]::CursorSize = 25


Function Add-OutputBoxLine {
    Param ($Message)
    $OutputBox.AppendText("`n$Message")
    $OutputBox.Refresh()
    $OutputBox.ScrollToCaret()
}

#endregion initialise

#region process

function dailyRSS {

# Currently looks a bit clunky, as there's one function per open source - work is ongoing to turn it into one function, 
# but is difficult to flexibly cater for all the ways different sources deliver their data

# function to test if file is open before proceeding
    function testFileLock {

    param (
        [parameter( Mandatory=$true )][string]$rssFilename
    )
    $oFile = New-Object System.IO.FileInfo $rssFilename
    if (( Test-Path -Path $rssFilename) -eq $false ) {
        return $false
    }
    try {
        $oStream = $oFile.Open( [System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None )
        if ( $oStream ) {
            $oStream.Close()
        }
        $false
        } catch {
# file is locked by a process.
            return $true
        }

    }


    if( testFileLock $rssFilename ) {
        Add-OutputBoxLine "{!} $rssFilename is open. Please close and run script again." -ForegroundColor Red
        Add-OutputBoxLine "{!} Script terminating in 5 seconds."
        Start-Sleep -s 5
        $guiForm.Close()
        return 
    }

    if(Test-Path $rssFilename) { Remove-Item $rssFilename }





    function httpcheck( $check_url ) {
# Quick basic check to see if RSS feed is up and responding
        $HTTP_req = [System.Net.WebRequest]::Create( $check_url )
        $HTTP_resp = $HTTP_req.GetResponse()
        $HTTP_status = [int]$http_resp.StatusCode
            If( $HTTP_Status -ne 200 ) { Add-OutputBoxLine "`n{!}$check_url is down or not responding" -ForegroundColor Red }
                $HTTP_resp.Close()
                
            }


    function matchCVE($message) {

# regex match for CVE reference
        if(( $message.link ) -match "nist") {
            $cvePattern = [Regex]::new( 'CVE-\d{4}-\d{4,7}' )
            $cveReference = $cvePattern.Matches($msg.link)
        } else {
            $cvePattern = [Regex]::new( '(?i)CVE-\d{4}-\d{4,7}' )
            $cveReference = $cvePattern.Matches( $message.description )
        }

        return $cveReference
    }


    function skipDays {
# if today is Monday, skip anything older than 5 days, else skip older than 3 days
        $today = ( Get-Date ).Date
        $weekday = ( get-Date ).dayofweek
        switch ( $weekday) {
            "Monday"    { [int]$num = -4 }
            Default     { [int]$num = -3 }
        }
        $testDate = [datetime]$today.AddDays( $num )
        $testDate

    }


    function bugtraq {

        $thisURI = "https://seclists.org/rss/bugtraq.rss"

        httpcheck($thisURI)
         
        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\bugtraq.xml

        [xml]$btContent = Get-Content $rssWorkingDirectory\bugtraq.xml

        $feed = $btContent.rss.channel
        
        $rssResult = foreach ($msg in $feed.Item) {
        
# format output
            if(($dlength = $msg.title.length) -gt 127) { $dlength = 127 }
            else { $dlength = $msg.title.length }

# regex setup to extract CVSS score from description

            $cvssPattern = [Regex]::new('.{5}(?=.CVSS:3)')

            $cvssScore = $cvssPattern.Matches($msg.description)

            if(([datetime]$msg.pubDate) -lt $tDate) { continue }


        [PSCustomObject]@{

            '----Source----' = "Bugtraq"

            '----LastUpdated----' = [datetime]$msg.pubDate

            '----Title----' = $msg.title.SubString(0,$dlength)

            '----Link----' = $msg.link

# uses the value from the cvss score regex match
            '----CVSSScore----' = $cvssScore.Value

# uses the value from the cve regex match
            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | Export-Csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }
    


    function fullDisclosure {

        $thisURI = "https://seclists.org/rss/fulldisclosure.rss"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\fulldisc.xml

        [xml]$fdContent = Get-Content $rssWorkingDirectory\fulldisc.xml

        $feed = $fdContent.rss.channel

        $rssResult = ForEach ($msg in $feed.Item) {

# format output
            if(($dlength = $msg.title.length) -gt 127) { $dlength = 127 }
            else { $dlength = $msg.title.length }

# regex setup to extract CVSS score from description

        $cvssPattern = [Regex]::new('.{5}(?=.CVSS:3)')

        $cvssScore = $cvssPattern.Matches($msg.description)

        if(([datetime]$msg.pubDate) -lt $tDate) { continue }

        [PSCustomObject]@{

            '----Source----' = "FullDisclosure"

            '----LastUpdated----' = [datetime]$msg.pubDate

            '----Title----' = $msg.title.substring(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = $cvssScore.Value

            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function vulMon {

        $thisURI = "https://vulmon.com/searchfeed?q=&sortby=bydate"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\vulmon.xml

        [xml]$vmContent = Get-Content $rssWorkingDirectory\vulmon.xml

        $feed = $vmContent.rss.channel

        $rssResult = foreach ($msg in $feed.Item) {

# format output
            if(($dlength = $msg.description.length) -gt 127) { $dlength = 127 }
            else { $dlength = $msg.description.length }

        [PSCustomObject]@{

            '----Source----' = "Vulmon"

            '----LastUpdated----' = Get-Date

            '----Title----' = $msg.description.SubString(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = $msg.cvssv3

            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function elReg {

        $thisURI = "https://www.theregister.co.uk/security/headlines.atom"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\elReg.xml

        [xml]$erContent = Get-Content $rssWorkingDirectory\elReg.xml

        $feed = $erContent.feed

        $rssResult = foreach ($msg in $feed.entry) {

# format output
            if(($dlength = $msg.title.'#text'.length) -gt 127) { $dlength = 127 }
            else { $dlength = $msg.title.'#text'.length }

        if(([datetime]$msg.updated) -lt $tDate) { continue }

        [PSCustomObject]@{

            '----Source----' = "elReg"

            '----LastUpdated----' = [datetime]$msg.updated

            '----Title----' = $msg.title.'#text'.Substring(0,$dlength)

            '----Link----' = $msg.link.href

            '----CVSSScore----' = ""

            '----CVE----' = ""

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function openSourceSec {

        $thisURI = "https://seclists.org/rss/oss-sec.rss"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\oss.xml

        [xml]$ossContent = Get-Content $rssWorkingDirectory\oss.xml

        $feed = $ossContent.rss.channel

        $rssResult = foreach ($msg in $feed.Item) {

# format output
        if(($dlength = $msg.title.length) -gt 127) { $dlength = 127 }
        else { $dlength = $msg.title.length }

        if(([datetime]$msg.pubDate) -lt $tDate) { continue }

        [PSCustomObject]@{

            '----Source----' = "OSS"

            '----LastUpdated----' = [datetime]$msg.pubDate

            '----Title----' = $msg.title.SubString(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = ""

            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function nist {

        $thisURI = "https://nvd.nist.gov/feeds/xml/cve/misc/nvd-rss.xml"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\nist.xml

        [xml]$nistContent = Get-Content $rssWorkingDirectory\nist.xml

        $feed = $nistContent.rdf

        $rssResult = foreach ($msg in $feed.item) {

# format output
        if(($dlength = $msg.description.length) -gt 127) { $dlength = 127 }
        else { $dlength = $msg.description.length }
 
        if(([datetime]$msg.date) -lt $tDate) { continue }
  
        [PSCustomObject]@{

            '----Source----' = "nist"

            '----LastUpdated----' = [datetime]$msg.date

            '----Title----' = $msg.description.SubString(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = ""

            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function secFocusVulns {

        $thisURI = "https://www.securityfocus.com/rss/vulnerabilities.xml"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\secfocusvuln.xml

        [xml]$sfvContent = Get-Content $rssWorkingDirectory\secfocusvuln.xml

        $feed = $sfvContent.rss.channel

        $rssResult = foreach ($msg in $feed.item) {

# skip records that match following terms
        if(($msg.title) -match "Bugtraq") { Continue }
        if(($msg.title) -match "More rss") { Continue }
        if(($msg.pubDate) -eq "") { Continue }

# format output
        if(($dlength = $msg.title.length) -gt 127) { $dlength = 127 }
        else { $dlength = $msg.title.length }

        if(([datetime]$msg.pubDate) -lt $tDate) { continue }

        [PSCustomObject]@{

            '----Source----' = "secfocusvuln"

            '----LastUpdated----' = [datetime]$msg.pubDate

            '----Title----' = $msg.title.SubString(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = ""

            '----CVE----' = (((matchCVE($msg)) | group | Select -ExpandProperty Name) -join ", ")

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
        Add-OutputBoxLine "$thisURI completed"
    }


    function secFocusnews {

        $thisURI = "https://www.securityfocus.com/rss/news.xml"

        httpcheck($thisURI)

        Invoke-RestMethod -uri $thisURI -OutFile $rssWorkingDirectory\secfocusnews.xml

        [xml]$sfnContent = Get-Content $rssWorkingDirectory\secfocusnews.xml

        $feed = $sfnContent.rss.channel

        $rssResult = foreach ($msg in $feed.item) {

# skip records that match following terms
        if(($msg.title) -match "More rss") { Continue }
        if(($msg.pubDate) -eq "") { Continue }

# format output
        if(($dlength = $msg.title.length) -gt 127) { $dlength = 127 }
        else { $dlength = $msg.title.length }

        if(([datetime]$msg.pubDate) -lt $tDate) { continue }

        [PSCustomObject]@{

            '----Source----' = "secfocusnews"

            '----LastUpdated----' = [datetime]$msg.pubDate

            '----Title----' = $msg.title.SubString(0,$dlength)

            '----Link----' = $msg.link

            '----CVSSScore----' = ""

            '----CVE----' = ""

        }#EndPSCustomObject

        }#EndForEach
        $rssResult | export-csv $rssFilename -Append
       Add-OutputBoxLine "$thisURI completed"
    }

    $tdate = skipDays

    Add-OutputBoxLine "{*} Downloading and parsing RSS feeds. Please wait..." -ForegroundColor Green
    Add-OutputBoxLine "{*} Content before $tDate will be ignored.`n"
    #write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 0
    bugtraq
    #write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 12.5
    fullDisclosure
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 25
    vulmon
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 37.5
    elReg
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 50
    openSourceSec
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 62.5
    nist
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 75
    secFocusVulns
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 87.5
    secFocusnews
    #Write-Progress -Activity "Processing..." -Status "% Complete:" -PercentComplete 100
    Add-OutputBoxLine "{*} All Complete." -ForegroundColor Green

    #Tidy up CSV file
    (Get-Content $rssFilename | Select-Object -Skip 1) | Set-Content $rssFilename

    #delete *.xml from working directory
    Remove-Item -path $rssWorkingDirectory\* -Include *.xml

    .$rssWorkingDirectory\rssfinal.csv

}

function patchTuesday {

    function getMonthOfInterest {
        $basedate = (get-date -day 12).Date
        $patchtues = $basedate.AddDays(2 - [int]$basedate.DayOfWeek)
        $patchtues = $patchtues.AddHours(20)


        if ( ((get-date).Date) -lt $patchtues) {
            $basedate = $basedate.AddMonths( -1 )
            $patchmonth = $basedate.ToString("yyyy-MMM")
            $patchmonth
        } else {
            $patchmonth = $basedate.ToString("yyyy-MMM")
            $patchmonth
        }
    }


        $monthOfInterest = getMonthOfInterest
        Add-OutputBoxLine "{*} Downloading $monthOfInterest rollup patch information from Microsoft. Please wait..." -ForegroundColor Green

        $reportdata = Get-MsrcCvrfDocument -ID  $MonthOfInterest | Get-MsrcCvrfAffectedSoftware

# Facts about raw data in $reportData
#
# 1) A single product can have multiple KB's associated with it
# 2) A single KB could be associated with multiple CVE's
# 3) A single raw row could have single or multiple KB's
# 4) A CVE could be associated with multiple products/KB's
# 5) For a single KB and product combination, "Severity, Impact, Restart required" could all be different. Eg: 3191828
# 6) Each raw row has
#       FullProductName - SingleValue
#       KBArticle       - Hashtable (EMPTY! in some cases)
#       CVE             - SingleValue
#       Severity        - SingleValue
#       Impact          - SingleValue
#       RestartRequired - Array (count matches Superdedence) but all values will be the same
#       Supercedence    - Array (count matches RestartRequired) but each array value is distinct
#       CvssScoreSet    - HashTable
# given the above,
# depending on the what you want to look at the data by,
# "Severity, Impact, RestartRequired" may be approximations (first or last occurance)


# these hashtables will hold specific associations as key and value as csv
# mostly kept for reference
        [hashtable]$cveByProductHash = @{}
        [hashtable]$kbByProductHash = @{}
        [hashtable]$productByKBHash = @{}
        [hashtable]$cveByKBHash = @{}
        [hashtable]$kbByCVEHash = @{}
        [hashtable]$productByCVEHash = @{}
 
# these hashtables will hold all data values as objects by the keys
# mostly kept for reference
        [hashtable]$cveByProductHashData = @{}
        [hashtable]$kbByProductHashData = @{}
        [hashtable]$productByKBHashData = @{}
        [hashtable]$cveByKBHashData = @{}
        [hashtable]$kbByCVEHashData = @{}
        [hashtable]$productByCVEHashData = @{}

        foreach($row in $reportData) {
            
# there is only one CVE per raw row
            $cveByProductHash["$row.FullProductName"] += ($row.CVE + ';')
# quotes added around $row.FullProductName to fix the "Index operation failed; the array index evaluated to null" bug.
 
# there are multiple KB's per raw row
            foreach($kb in $row.KBArticle) {
 
        # ----- By CVE --------
                $kbByCVEHashData[$row.CVE] = [pscustomobject]@{
                    'CVE' = $row.CVE
                    'Severity'= $row.severity
                    'Impact'= $row.impact
                    'CVSS_base' = $row.CvssScoreSet.base
                    'CVSS_temporal' = $row.CvssScoreSet.temporal
                    'CVSS_vector' = $row.CvssScoreSet.vector
                }
            }
        }

<# This is a hangover from the old script, kept purely for reference if different results are required.

switch ($resultType)
        {
            'RAW'           {$reportData}
            'CVEByProduct'  {$cveByProductHashData.Values}
            'KBByProduct'   {$kbByProductHashData.Values}
            'ProductByKB'   {$productByKBHashData.Values}
            'CVEByKB'       {$cveByKBHashData.Values}
            'KBByCVE'       {$kbByCVEHashData.Values}
            'ProductByCVE'  {$productByCVEHashData.Values}
        }
#>


# unfiltered output file for data integrity checking
            Add-OutputBoxLine "{*} Producing raw csv...(for sanity checking)" -ForegroundColor Green
            $reportData | Export-Csv $ptFilename_raw

# filtered on CVE
            Add-OutputBoxLine "{*} Producing consolidated csv..." -ForegroundColor Green
            $kbByCVEHashData.Values | Export-Csv $ptFilename

# tidy up CSV file
            (Get-Content $ptFilename | Select-Object -Skip 1) | Set-Content $ptFilename
            (Get-Content $ptFilename_raw | Select-Object -Skip 1) | Set-Content $ptFilename_raw

# open files
            .$ptFilename
            .$ptFilename_raw


}


#region GUI

[void] [System.Reflection.Assembly]::LoadWithPartialName("System.Drawing") 
[void] [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")  

#### Form settings ################################################################# 
$guiForm = New-Object System.Windows.Forms.Form
$guiForm.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::Sizable
$guiForm.Text = "Patch Checks"   
$guiForm.Size = New-Object System.Drawing.Size(1010,600)
$guiForm.StartPosition = "CenterScreen" #loads the window in the center of the screen
$guiForm.BackgroundImageLayout = "Zoom"
$guiForm.MinimizeBox = $true
$guiForm.MaximizeBox = $true
$guiForm.WindowState = "Normal"
$guiForm.SizeGripStyle = "Hide"
$guiIcon = [system.drawing.icon]::ExtractAssociatedIcon($PSHOME + "\powershell.exe")
$guiForm.Icon = $guiIcon

# tooltip scriptblock
$showHelp={
 Switch ($this.name) {
        "daily_rss" { $tip = "Run daily RSS checks"}
        "patch_tues" { $tip = "Monthly Microsoft Patch Tuesday" }
    }
    $guiToolTip.SetToolTip($this,$tip)
 }

 $guiToolTip = New-Object System.Windows.Forms.Tooltip
     

    #### Group boxes for buttons ########################################################
    $guiButtonGroup = New-Object System.Windows.Forms.GroupBox
    $guiButtonGroup.Location = New-Object System.Drawing.Size(10,95) 
    $guiButtonGroup.size = New-Object System.Drawing.Size(180,250)
    $guiButtonGroup.text = "Actions"
    $guiForm.Controls.Add($guiButtonGroup) 


    #### On Demand button #################################################################
    $dailyRss = New-Object System.Windows.Forms.Button
    $dailyRss.Location = New-Object System.Drawing.Size(15,30)
    $dailyRss.Size = New-Object System.Drawing.Size(150,40)
    $dailyRss.Text = "Daily RSS Checks"
    $dailyRss.Add_Click({dailyRSS})
    #region tooltip
    $dailyRss.name = "daily_rss"
    $dailyRss.add_MouseHover($showHelp)
    #endregion tooltip
    # change cursor.
    #$runAllExclMem.Cursor = [System.Windows.Forms.Cursors]::Hand
    $guiButtonGroup.Controls.Add($dailyRss)

    #### On Access button #################################################################
    $patchTuesday = New-Object System.Windows.Forms.Button
    $patchTuesday.Location = New-Object System.Drawing.Size(15,70)
    $patchTuesday.Size = New-Object System.Drawing.Size(150,40)
    $patchTuesday.Text = "Download Patch Tuesday Updates"
    $patchTuesday.Add_Click({patchTuesday})
    #region tooltip
    $patchTuesday.name = "patch_Tues"
    $patchTuesday.add_MouseHover($showHelp)
    #endregion tooltip
    $guiButtonGroup.Controls.Add($patchTuesday)

    

    ###################### END BUTTONS ######################################################


    #### Output Box Field ###############################################################
    $outputBox = New-Object System.Windows.Forms.RichTextBox
    $outputBox.Location = New-Object System.Drawing.Size(200,10) 
    $outputBox.Size = New-Object System.Drawing.Size(785,545)
    $outputBox.Font = New-Object System.Drawing.Font("Consolas", 8 ,[System.Drawing.FontStyle]::Regular)
    $outputBox.MultiLine = $true
    $outputBox.ScrollBars = "Vertical"
    $outputBox.Text = "
    "
    # enable resizing with window
    $outputBox.anchor = [System.Windows.Forms.AnchorStyles]::Top `
    -bor [System.Windows.Forms.AnchorStyles]::Left `
    -bor [System.Windows.Forms.AnchorStyles]::Right `
    -bor [System.Windows.Forms.AnchorStyles]::Bottom
    $guiForm.Controls.Add($outputBox)
 
    ##############################################
 

    $guiForm.Add_Shown({$guiForm.Activate()})
    [void] $guiForm.ShowDialog()

#endregion gui

#endregion process


#region finalise


#endregion finalise
